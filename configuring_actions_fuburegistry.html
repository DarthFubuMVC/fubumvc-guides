<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Configuring Actions in FubuRegistry</title>

<link rel="stylesheet" type="text/css" href="files/stylesheets/style.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/syntax.css" />
<link rel="stylesheet" type="text/css" href="files/stylesheets/print.css" media="print" />

<script type="text/javascript" src="files/javascripts/guides.js"></script>
<script type="text/javascript" src="files/javascripts/code_highlighter.js"></script>
<script type="text/javascript" src="files/javascripts/highlighters.js"></script>

</head>
<body class="guide">
  <div id="topNav">
    <div class="wrapper">
      <strong>More at <a href="http://fubumvc.com">http://fubumvc.com:</a> </strong>
      <a href="http://github.com/DarthFubuMVC/fubumvc">Fork it!</a> |
      <a href="http://groups.google.com/group/fubumvc-devel">Mailing list</a> |      
    </div>
  </div>
  <div id="header">
    <div class="wrapper clearfix">
      <h1><a href="index.html" title="Guides">Guides</a></h1>
      <p class="hide"><a href="#mainCol">Skip navigation</a>.</p>
      <ul class="nav">
        <li><a href="index.html">Home</a></li>
        <li class="index"><a href="index.html" onclick="guideMenu(); return false;" id="guidesMenu">Guides Index</a>
          <div id="guides" class="clearfix" style="display: none;">
            <hr />
            <dl class="L">
              <dt>Start Here</dt>
              <dd><a href="getting_started.html">Getting Started with FubuMVC</a></dd>
			  <dd><a href="configuring_actions_fuburegistry.html">FubuRegistry: Configuring Actions</a></dd>
              <dd><a href="behaviors.html">Composition with Behaviors</a></dd>
              <dd><a href="advanced_behaviors.html">Advanced Behaviors</a></dd>
                 
            </dl>
            <dl class="R">              
            </dl> 
          </div>
        </li>
        <li><a href="contribute.html">Contribute</a></li>
        <li><a href="credits.html">Credits</a></li>
      </ul>
    </div>
  </div>

  <div id="feature">
    <div class="wrapper">
      <h2>Configuring Actions in FubuRegistry</h2>
<p>This guide covers configuring, in your FubuRegistry, which actions FubuMVC will process. After reading it, you should be familiar with configuring:</p>
<ul>
	<li>Which assemblies, types, and methods FubuMVC will consider when looking for action methods.</li>
	<li>How FubuMVC will generate routes for each action</li>
	<li>What the output mechanism will be for each action (i.e. <span class="caps">HTML</span>, <span class="caps">JSON</span>, <span class="caps">XML</span>, etc)</li>
	<li>Which view, if necessary, a given action will use</li>
</ul>
<div class='note'><p>All the code use in this guide is available under the &#8220;src&#8221; folder in the <a href="http://github.com/DarthFubuMVC/fubumvc-guides">fubumvc-guides repository on GitHub</a></p></div>

            <div id="subCol">
        <h3 class="chapter"><img src="images/chapters_icon.gif" alt="" />Chapters</h3>
        <ol class="chapters">
<li><a href="#this-guide-assumes">This Guide Assumes&#8230;</a><ul></ul></li><li><a href="#settingupyour-fubu-registry">Setting up your FubuRegistry</a><ul></ul></li><li><a href="#action-discovery">Action Discovery</a><ul><li><a href="#assembly-location">Assembly Location</a></li><li><a href="#containing-typesand-action-methods">Containing Types and Action Methods</a></li></ul></li><li><a href="#configuring-routes">Configuring Routes</a><ul><li><a href="#basic-route-configuration">Basic Route Configuration</a></li><li><a href="#custom-route-policies">Custom Route Policies</a></li><li><a href="#constrainingby-http-method">Constraining by <span class="caps">HTTP</span> Method</a></li><li><a href="#conventions-are-your-friend">Conventions Are Your Friend!</a></li></ul></li><li><a href="#attaching-viewsto-actions">Attaching Views to Actions</a><ul></ul></li><li><a href="#attaching-outputsto-actions">Attaching Outputs to Actions</a><ul></ul></li><li><a href="#summary">Summary</a><ul></ul></li></ol></div>
    </div>
  </div>

  <div id="container">
    <div class="wrapper">
      <div id="mainCol">
        <h3 id="this-guide-assumes">1 This Guide Assumes&#8230;</h3>
<ul>
	<li>That you&#8217;ve already got a basic FubuMVC starter app up and running (if not, check out the <a href="getting_started.html">getting started guide</a>.</li>
	<li>That you&#8217;re ready to start making some action methods and types and wire them up to routes and views through FubuMVC</li>
	<li>That you&#8217;re plan on using the <span class="caps">ASP</span>.<span class="caps">NET</span> WebForms View Engine. This guide is not yet adapted for the Spark or other view engines, but many of the techniques are applicable to all view engines.</li>
</ul>
<h3 id="settingupyour-fubu-registry">2 Setting up your FubuRegistry</h3>
<p>The first thing you need to configure FubuMVC is a class somewhere in your web project that derives from <tt>FubuRegistry</tt>.  You can call this class anything, but a common convention is to call it <tt>ProjectNameFubuRegistry</tt> where <em>ProjectName</em> is your project&#8217;s name or code-name.</p>
<p>All the configuration for your <tt>FubuRegistry</tt>-derived class takes place in the constructor. Your class will need a default constructor for this purpose.</p>
<div class='code_container'><code class='html'>
    public class MyProjectFubuRegistry : FubuRegistry
    {
        public MyProjectFubuRegistry()
        {
            //TODO: FubuMVC configuration here
        }
    }

</code></div><h3 id="action-discovery">3 Action Discovery</h3>
<p>When configuring your FubuRegistry, the first thing you need to tell it is where your assemblies are and which types and methods should be considered &#8220;actions&#8221;.</p>
<div class='info'><p>An <em>action</em> is any method which will be executed when a route is requested by the client browser. Some people like have one action per .<span class="caps">NET</span> class, some people like to group several actions into a class and call this class a <em>Controller</em>.  FubuMVC only cares about action methods and not much about the containing type.</p></div>
<h4 id="assembly-location">3.1 Assembly Location</h4>
<p>Action assemblies are configured via the <tt>Applies</tt> property on <tt>FubuRegistry</tt>.  FubuMVC will only scan assemblies you tell it to. If you don&#8217;t mention it here to FubuMVC, those types won&#8217;t be considered for action discovery!</p>
<p>To tell FubuMVC which assemblies to consider, simply type <tt>Applies</tt> then a period inside your constructor and you should see the applicable methods on this property. The options available are:</p>
<ul>
	<li><tt>ToThisAssembly()</tt>: The assembly containing your <tt>FubuRegistry</tt> class (i.e. your web project)</li>
	<li><tt>ToAssembly(_assembly_)</tt>: A specific assembly by name or reference</li>
	<li><tt>ToAssemblyContainingType<T>()</tt>:  The assembly containing a specific well-known type (i.e. <tt>MyProject.Actions.FooActions</tt>)</li>
</ul>
<div class='info'><p>Repeated calls to <tt>Applies</tt> are cumulative. You can keep calling and re-calling these methods to build up a list of assemblies for FubuMVC to scan.</p></div>
<h4 id="containing-typesand-action-methods">3.2 Containing Types and Action Methods</h4>
<p>Now that we have told FubuMVC how to locate the assemblies we care about, you need to tell it which types in those assemblies, and which methods on those types FubuMVC should turn into actions. This is accomplished via <span class="caps">API</span> exposed through the <tt>Actions</tt> property on <tt>FubuRegistry</tt>.</p>
<p>Like the <tt>Applies</tt> <span class="caps">API</span>, everything on <tt>Actions</tt> is cumulative.  There are several methods that start with the name &#8220;Include&#8221; and several that start with &#8220;Exclude&#8221;. This is because your &#8220;Include&#8221; calls may include too much and you may wish to cherry-pick a few types or methods out of the list of actions.</p>
<p>By default, FubuMVC will not look at any types for actions. If you don&#8217;t &#8220;Include&#8221; any types, you will have no actions!  Also, by default, public methods on any types which you have included will be considered actions.</p>
<p>Here is a simple example of configuring FubuMVC to consider all types whose name ends with &#8220;Controller&#8221; and types that implement your project&#8217;s <tt>IAction</tt> interface as action-containing types:</p>
<div class='code_container'><code class='html'>
            Actions
                .IncludeTypesNamed(x =&gt; x.EndsWith(&quot;Controller&quot;))
                .IncludeTypesImplementing&lt;IAction&gt;();

</code></div><div class='warning'><p>FubuMVC requires action methods to be one-model-in/one-model-out (<span class="caps">OMIOMO</span>), zero-model-in/one-model-out (<span class="caps">ZMIOMO</span>), or one-model-in/zero-model-out (<span class="caps">OMIZMO</span>). All input and output models must be reference types (<tt>class</tt>) not value types (<tt>struct</tt>). If your method doesn&#8217;t match this criteria, you will get a fatal error upon app start (an <span class="caps">ASP</span>.<span class="caps">NET</span> Yellow Screen of Death).</p></div>
<div class='info'><p>Though FubuMVC doesn&#8217;t require it, it is good practice to avoid having any public methods on action-containing types (or &#8220;controllers&#8221; if you prefer) that you don&#8217;t intend to be actions. If you really must have non-action methods on your action-containing types, consider using the <tt>ExcludeMethod()</tt> method on the <tt>Actions</tt> <span class="caps">API</span>.</p></div>
<h3 id="configuring-routes">4 Configuring Routes</h3>
<div class='warning'><p>However you configure your routes (default, custom, etc) they must be unique by route <span class="caps">URL</span> stub and <span class="caps">HTTP</span> method. If you end up somehow with duplicate routes, FubuMVC will fail on app start with a fatal error (<span class="caps">ASP</span>.<span class="caps">NET</span> Yellow Screen of Death).</p></div>
<h4 id="basic-route-configuration">4.1 Basic Route Configuration
Routes, like most things in FubuMVC, are applied conventionally. This means you can set them explicitly, or configure FubuMVC with rules by which it should automatically determine routes for actions.</h4>
<div class='info'><p>In FubuMVC, routes are the <span class="caps">URL</span> stubs by which a given action can be invoked. For example <em>/people/charlie</em> might map to the <tt>Load()</tt> method on the <tt>PeopleAction</tt> type (or <tt>Index</tt> method on the <tt>PeopleController</tt> if you like to use the term &#8220;Controller&#8221; for action types).</p></div>
<p>If you don&#8217;t specify otherwise, FubuMVC will generate a route like this:</p>
<div class="code_container"><code class="html">
/your/namespace/here/typename/methodname
</code></div>
<p>This means that <tt>Index</tt> method in the the C# class in the file <em>YourProject\Controllers\Home\HomeController.cs</em> would result in the route: <em>/yourproject/controllers/home/home/index</em>  (FubuMVC automatically strips out the text &#8220;Controller&#8221; if your action-containing type ends with &#8220;Controller&#8221;).  This is almost certainly not the route you&#8217;d want for this action.  More than likely what you want is just <em>/home</em>.</p>
<p>To configure this, start with the <tt>Routes</tt> <span class="caps">API</span> hanging off of <tt>FubuRegistry</tt>.  Almost all the methods on this <span class="caps">API</span> are subtractive. They take away things from the default <span class="caps">URL</span>.  For example, <tt>IgnoreControllerFolderName</tt> would result in the route <em>/yourproject/controllers/home</em>. <tt>IgnoreControllerNamespaceEntirely()</tt> would result in the entire namespace (including the action-containin types&#8217;s folder name) to be removed from the route, resulting in the much more pleasant <em>/home/index</em>.</p>
<p>Let&#8217;s say that your project has a standard that you use the <tt>Index()</tt> action as the default for your routes. Thus the <em>/home/index</em> route should really be <em>/home</em>.  This is where <tt>IgnoreMethodsNamed()</tt> comes in handy.  If you used that, you&#8217;d end up with the route <em>/home</em>.</p>
<p>Using our examples above, your <tt>Routes</tt> configuration would look something like:</p>
<div class='code_container'><code class='html'>
            Routes
                .IgnoreControllerNamespaceEntirely()
                .IgnoreMethodsNamed(&quot;Index&quot;);

</code></div><h4 id="custom-route-policies">4.2 Custom Route Policies</h4>
<p>If you really just can&#8217;t stand how the default route generation works in FubuMVC, or you need to do something very specific for your circumstances you can always override the whole thing with your own custom <tt>IUrlPolicy</tt> implementation.</p>
<tt>IUrlPolicy</tt>implementations are configured as a fall-through. You can add multiple different implementations each targeted towards a particular problem or set of problems you&#8217;re trying to overcome.
<p>Implementations will be queried in the order in which they were registered with the <tt>Routes</tt> <span class="caps">API</span> (first policy added first, last one added is considered last).  If no policy matches, the default policy will be used as a back-stop. In the end, every action will get a route guaranteed.</p>
<p>Register custom <tt>IUrlPolicy</tt> implementations using the <tt>UrlPolicy<T>()</tt> method on the <tt>Routes</tt> <span class="caps">API</span>.</p>
<h4 id="constrainingby-http-method">4.3 Constraining by <span class="caps">HTTP</span> Method</h4>
<p>Routes are considered unique by both their <span class="caps">URL</span> stub and their <span class="caps">HTTP</span> method. For example, the route <em>/login</em> for <span class="caps">GET</span> requests goes to action <tt>LoginController.Index()</tt> but the route <em>/login</em> for <span class="caps">POST</span> requests goes to <tt>LoginController.Login()</tt>. In FubuMVC, these actions and their routes are considered distinct, unique routes since they occur on different <span class="caps">HTTP</span> methods.</p>
<p><span class="caps">HTTP</span> method constraints can and should be applied conventionally. We recommend you establish your own convention for which methods are <span class="caps">GET</span> versus <span class="caps">POST</span> methods. For example, methods which are supposed to be <span class="caps">POST</span>-only are called <tt>Command()</tt> or <tt>Post()</tt>. To configure this convention, use the <tt>ConstrainHttpMethod()</tt> method on the <tt>Routes</tt> <span class="caps">API</span>. Consider this example:</p>
<div class='code_container'><code class='html'>
            Routes.ConstrainToHttpMethod(x =&gt; x.Method.Name == &quot;Post&quot;, &quot;POST&quot;);

</code></div><p>Now all action methods in your application that are named &#8220;Post()&#8221; will be <span class="caps">HTTP</span> <span class="caps">POST</span>-only methods.</p>
<h4 id="conventions-are-your-friend">4.4 Conventions Are Your Friend!</h4>
<p>We highly recommend that you encapsulate your application&#8217;s naming and routing rules into custom <tt>IUrlPolicy</tt> implementations rather than having a lot of bloat and cruft build up in your FubuRegistry implementation. We also highly recommend that you create a conventional pattern for locating, naming, and constraining your action-containing types and your action methods.</p>
<p>For example, we recommend you have convention similar to this:</p>
<ul>
	<li>All actions are contained in types that end with &#8220;Action&#8221; (i.e. HomeAction)</li>
	<li>All action-containing types have one or two methods: <tt>Get</tt> and <tt>Post</tt> or <tt>Query</tt> and <tt>Command</tt></li>
	<li>The <tt>Get</tt>/<tt>Query</tt> methods are wired as <span class="caps">HTTP</span> <span class="caps">GET</span>-only methods and <tt>Post</tt>/<tt>Command</tt> methods are wired up as <span class="caps">HTTP</span> <span class="caps">POST</span>-only</li>
</ul>
<p>Create an <tt>IUrlPolicy</tt> implementation called, for example <tt>ActionGetAndPostUrlPolicy</tt> or <tt>ActionQueryCommandUrlPolicy</tt> and register it using the <tt>UrlPolicy<T></tt> method on the <tt>Routes</tt> <span class="caps">API</span>.</p>
<p>Here&#8217;s a rather naive example of the ActionQueryCommandUrlPolicy:</p>
<div class='code_container'><code class='html'>
    public class ActionQueryCommandUrlPolicy : IUrlPolicy
    {
        public bool Matches(ActionCall call, IConfigurationObserver log)
        {
            return
                call.HandlerType.Name.EndsWith(&quot;Action&quot;)
                &amp;&amp; (
                    call.Method.Name.Equals(&quot;Query&quot;)
                    || call.Method.Name.Equals(&quot;Command&quot;)
                );
        }

        public IRouteDefinition Build(ActionCall call)
        {
            var handler = call.HandlerType.Name.Replace(&quot;Action&quot;, &quot;&quot;);
            var methodName = call.Method.Name;
            var pattern = &quot;{0}&quot;.ToFormat(handler);

            var definition = call.HasInput
                ? RouteBuilder.Build(call.InputType(), pattern)
                : new RouteDefinition(pattern);

            var httpMethod = methodName.Equals(&quot;Query&quot;) ? &quot;GET&quot; : &quot;POST&quot;;

            definition.AddRouteConstraint(
                    RouteConstraintPolicy.HTTP_METHOD_CONSTRAINT,
                    new HttpMethodConstraint(httpMethod));

            return definition;
        }
    }

</code></div><h3 id="attaching-viewsto-actions">5 Attaching Views to Actions</h3>
<p>Many of your actions will return <span class="caps">HTML</span> to the the client browser. For actions that don&#8217;t, see the next section. Views are conventionally attached to actions view the <tt>TryToAttach()</tt> method (and nested closure) on the <tt>Views</tt> <span class="caps">API</span> off of <tt>FubuRegistry</tt>.</p>
<p>FubuMVC will scan all the assemblies you told it about (from the a few sections ago via the <tt>Applies</tt> <span class="caps">API</span>) and look for <span class="caps">ASP</span>.<span class="caps">NET</span> <tt>Page</tt> classes that derive from <tt>FubuPage<TOutputModel></tt>.  This means that FubuMVC does not currently support code-behind-less views though we are definitely looking to add that at some point in the near future (if you really want this, we could sure use the help to implement it! hint hint).</p>
<p>There are, by default, three different ways FubuMVC will try to attach actions to views. <span class="caps">ASP</span>.<span class="caps">NET</span> WebForms views must be strongly-typed and derive from <tt>FubuPage<TOutputModel></tt> where <tt>TOutputModel</tt> is the output model of the action method to which the view will be attached. You can use all three ways, just two, or just one if you wish. They are applied cumulatively in the order that they&#8217;re specified (i.e. it&#8217;s a fall-through to find the view). There is no back-stop for wiring up views to actions. If no view could be found for a given action, FubuMVC will not raise an error. This is because not all actions result in view-rendering. Some spit out <span class="caps">JSON</span> or <span class="caps">XML</span> or other things. If you run into difficulties getting view matching to work, consider using FubuMVC Diagonostics (mentioned in the <a href="getting_started.html">getting started guide</a>) which may help explain why things are lining up properly.</p>
<p>There are three methods on the exposed by the nested closure of the <tt>TryToAttach</tt> method on the <tt>Views</tt> <span class="caps">API</span>. These represent the three default ways of matching views to actions in FubuMVC:</p>
<ol>
	<li><tt>by_ViewModel</tt>: FubuMVC will only consider the output model type of the action and try to match it against the <tt>TOutputModel</tt> of the WebForm page&#8217;s <tt>FubuPage<TOutputModel></tt> designation.</li>
	<li><tt>by_ViewModel_and_Namespace</tt>: FubuMVC will consider the output model type (the same as above) and also match the namespace of the page to the namespace of the action-containing type (i.e. controller class). This allows you to have multiple views based off the same viewmodel in different namespaces without having conflicts or duplicate matches.</li>
	<li><tt>by_ViewModel_and_Namespace_and_MethodName</tt>: Considers all the above criteria, but requires that the view itself be named the same as the method. For example if your action method name is &#8220;Index()&#8221;, the view must be &#8220;Index.aspx&#8221;. This is the most restrictive of all patterns, but allows the greatest flexibility for reuse of viewmodels among many different views.</li>
</ol>
<h3 id="attaching-outputsto-actions">6 Attaching Outputs to Actions</h3>
<p>For actions that you don&#8217;t want to return an <span class="caps">HTML</span> view from (for example a <span class="caps">JSON</span> or <span class="caps">XML</span> request), use the <tt>Output</tt> <span class="caps">API</span> on your FubuRegistry class.</p>
<p>The most common use of this <span class="caps">API</span> is for wiring up actions to <span class="caps">JSON</span> output (for invocation by your favorite client-side JavaScript framework such as jQuery. You can use the <tt>ToJson</tt> property on the <tt>Output</tt> <span class="caps">API</span> for this purpose. There are two options: Attach to an action by an arbitrary critera or (more common) by the action&#8217;s output model.</p>
<div class='info'><p>From our experience, it&#8217;s generally better to use the same output type for marshalling all types of <span class="caps">JSON</span> messages back to the client so they can be processed consistently on the client (for error handling, success handling, timeout handling, etc).</p></div>
<p>If your <span class="caps">JSON</span> output type is, for example <tt>JsonResponse</tt>, you could use the <tt>WhenTheOutputModelIs<JsonResponse>()</tt> method. This will instruct FubuMVC to wire up a <span class="caps">JSON</span> output handler for all action methods that return a <tt>JsonResponse</tt> model object.</p>
<p>You can also define your own custom output modes using the <tt>To</tt> method. How to use this method is worth a guide itself and is probably beyond the scope of this already too-long guide. You could always use the <a href="http://groups.google.com/group/fubumvc-devel">mailing list</a> if you want help with this.</p>
<h3 id="summary">7 Summary</h3>
<p><strong>Congratulations!</strong>  You&#8217;ve made it through this guide.</p>
<p>In this guide you&#8217;ve seen how to :</p>
<ul>
	<li>Discover your action assemblies, types, and methods</li>
	<li>Determine how your actions will be routed via <span class="caps">URL</span> and <span class="caps">HTTP</span> method</li>
	<li>How to use <tt>IUrlPolicy</tt> to define and encapsulate your project&#8217;s route conventions</li>
	<li>Match actions to their corresponding views</li>
	<li>Determine the output type for actions which don&#8217;t render views</li>
</ul>
      </div>
    </div>
  </div>

  <hr class="hide" />
  <div id="footer">
    <div class="wrapper">
      <p>This work is licensed under a <a href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-Share Alike 3.0</a> License</a></p>
    </div>             
    
    <script type="text/javascript">
    	var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
    	document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>
    <script type="text/javascript">
    	var pageTracker = _gat._getTracker("");
    	pageTracker._initData();
    	pageTracker._trackPageview();
    </script>
        
  </div>
</body>
</html>
